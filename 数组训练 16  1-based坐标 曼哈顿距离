#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, m, k;  // 定义变量：n=方阵大小，m=火把数量，k=萤石数量
    scanf("%d %d %d", &n, &m, &k);  // 读取输入的三个整数
    
    int grid[105][105] = {0};  // 创建105×105的网格数组，初始所有值为0
                               // 0表示暗（会生成怪物），1表示亮（安全）
                               // 使用105大小是为了确保n≤100时不会数组越界
    int count = 0;             // 计数器，用于统计会生成怪物的格子数量
    
    // ==================== 处理所有火把的照明效果 ====================
    // 循环m次，处理每个火把
    for(int i = 0; i < m; i++) {
        int x, y;  // 定义变量存储当前火把的坐标
        scanf("%d %d", &x, &y);  // 读取火把的位置坐标（1-based坐标系统）
        
        // 遍历以火把为中心的5×5区域（从-2到+2）
        for(int dx = -2; dx <= 2; dx++) {      // dx：行方向的偏移量（-2,-1,0,1,2）
            for(int dy = -2; dy <= 2; dy++) {  // dy：列方向的偏移量（-2,-1,0,1,2）
                
                // 判断当前偏移位置是否在火把的照明范围内
                // 火把照明范围：曼哈顿距离 ≤ 2 的菱形区域
                // 曼哈顿距离公式：|dx| + |dy|
                if(abs(dx) + abs(dy) <= 2) {
                    // 计算目标位置的坐标
                    int nx = x + dx;  // 新行坐标 = 火把行坐标 + 行偏移
                    int ny = y + dy;  // 新列坐标 = 火把列坐标 + 列偏移
                    
                    // 边界检查：确保计算出的坐标在有效的网格范围内
                    // nx >= 1：行坐标不小于1（避免上边界越界）
                    // nx <= n：行坐标不大于n（避免下边界越界）
                    // ny >= 1：列坐标不小于1（避免左边界越界）
                    // ny <= n：列坐标不大于n（避免右边界越界）
                    if(nx >= 1 && nx <= n && ny >= 1 && ny <= n) {
                        grid[nx][ny] = 1;  // 标记该位置为照亮状态
                    }
                }
            }
        }
    }
    
    // ==================== 处理所有萤石的照明效果 ====================
    // 循环k次，处理每个萤石
    for(int i = 0; i < k; i++) {
        int x, y;  // 定义变量存储当前萤石的坐标
        scanf("%d %d", &x, &y);  // 读取萤石的位置坐标（1-based坐标系统）
        
        // 遍历以萤石为中心的5×5区域（从-2到+2）
        for(int dx = -2; dx <= 2; dx++) {      // dx：行方向的偏移量
            for(int dy = -2; dy <= 2; dy++) {  // dy：列方向的偏移量
                
                // 计算目标位置的坐标
                int nx = x + dx;  // 新行坐标 = 萤石行坐标 + 行偏移
                int ny = y + dy;  // 新列坐标 = 萤石列坐标 + 列偏移
                
                // 边界检查：确保坐标在有效范围内[1, n]
                if(nx >= 1 && nx <= n && ny >= 1 && ny <= n) {
                    grid[nx][ny] = 1;  // 标记该位置为照亮状态
                    // 注意：萤石没有曼哈顿距离限制，整个5×5区域都照亮
                }
            }
        }
    }
    
    // ==================== 统计会生成怪物的格子数量 ====================
    // 遍历整个n×n方阵的所有格子
    for(int i = 1; i <= n; i++) {        // 遍历每一行（从第1行到第n行）
        for(int j = 1; j <= n; j++) {    // 遍历每一列（从第1列到第n列）
            
            // 检查当前格子是否暗（值为0）
            if(grid[i][j] == 0) {
                count++;  // 如果是暗的，计数器加1
            }
        }
    }
    
    // 输出最终结果：会生成怪物的格子数量
    printf("%d\n", count);
    
    return 0;  // 程序正常结束
}
