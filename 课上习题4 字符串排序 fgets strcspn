字符串排序
【问题描述】

编写程序，输入n（n≤1000）个字符串，将n个字符串排序后输出。字符串的长度小于100。

【输入形式】

第1行为整数n，接下来n行，每行为一个字符串。
【输出形式】

n行，排序后的字符串。
【样例输入】

4

Software Engineering

Computer Science

Artificial Intelligence

Electronic Information



【样例输出】

Artificial Intelligence

Computer Science


Electronic Information

Software Engineering


【样例说明】

注意：整数4后有一个回车。

-----------------------------------------------------------------------------------------------------

#include <stdio.h>  // 引入标准输入输出头文件，提供printf/scanf/fgets等IO函数
#include <string.h> // 引入字符串处理头文件，提供strcmp/strcpy/strcspn等字符串函数

// 冒泡排序函数：对二维字符数组按字符串字典序升序排序
void bubble_sort(char strs[][101], int n) {
    for (int i = 0; i < n-1; i++) { // 外层循环：控制排序轮数，共n-1轮
        for (int j = 0; j < n-1-i; j++) { // 内层循环：逐轮比较相邻元素，已排序末尾i个元素无需比较
            if (strcmp(strs[j], strs[j+1]) > 0) { // 比较相邻字符串，前>后则交换（实现升序）
                char temp[101]; // 定义临时数组，用于暂存交换的字符串
                strcpy(temp, strs[j]); // 将前一个字符串拷贝到临时数组
                strcpy(strs[j], strs[j+1]); // 后一个字符串覆盖前一个位置
                strcpy(strs[j+1], temp); // 临时数组内容覆盖后一个位置，完成交换
            }
        }
    }
}

int main() {
    int n; // 定义变量n，存储待排序的字符串个数
    scanf("%d", &n); // 读取用户输入的字符串个数n
    getchar(); // 清除scanf残留的换行符，避免fgets读空行

    char strs[n][101]; // 定义二维变长数组，n行101列，每行存1个字符串（含'\0'）

    for (int i = 0; i < n; i++) { // 循环读取n个字符串
        fgets(strs[i], sizeof(strs[i]), stdin); // 安全读取一行字符串到数组第i行
        strs[i][strcspn(strs[i], "\n")] = '\0'; // 定位换行符并替换为'\0'，去除fgets读入的换行
    }

    bubble_sort(strs, n); // 调用冒泡排序函数，对字符串数组排序

    for (int i = 0; i < n; i++) { // 循环输出排序后的字符串
        printf("%s\n", strs[i]); // 输出第i个字符串，%s自动识别'\0'终止符
    }

    return 0; // 主函数返回0，标识程序正常结束
}

------------------------------------------------------------------------------------------------

笔记区
### 一、fgets 核心重点 + 高频易错点
#### 核心重点
1. **函数本质**：安全的行读取函数，替代 `scanf("%s")` 解决「带空格读取」「缓冲区溢出」问题；
2. **核心规则**：
   - 原型：`char *fgets(char *str, int size, FILE *stream)`；
   - 读取终止条件：读到 `\n` / `EOF` / `size-1` 个字符，**自动在末尾加 `'\0'`**；
   - 支持读取带空格/制表符的整行字符串，`stream` 填 `stdin` 表示键盘输入。
3. **核心用法**：读取用户输入的完整字符串（如排序场景中的多行字符串）。

#### 高频易错点
| 易错点                | 表现/后果                          | 解决方案                                  |
|-----------------------|------------------------------------|-------------------------------------------|
| 未清理 `scanf` 残留符 | `scanf` 后直接用 `fgets` 读空行    | `scanf` 后用 `while((c=getchar())!='\n'&&c!=EOF);` 清空缓冲区 |
| 保留换行符 `\n`       | 输出多空行、字符串比较异常         | 配合 `strcspn` 替换 `\n` 为 `'\0'`        |
| 忽略返回值            | 读取失败（EOF/流异常）时操作 `str` 崩溃 | 判断返回值：`if(fgets(...)==NULL) { 报错退出 }` |
| 误解 `size` 参数      | 认为 `size` 是“要读取的字符数”     | 牢记 `size` 是缓冲区长度，最多读 `size-1` 个字符 |
| 二进制文件误用        | 读取图片/视频等二进制数据不完整    | 二进制读取用 `fread`，而非 `fgets`         |

### 二、strcspn 核心重点 + 高频易错点
#### 核心重点
1. **函数本质**：字符查找工具，专门解决 `fgets` 换行符问题；
2. **核心规则**：
   - 原型：`size_t strcspn(const char *str, const char *reject)`；
   - 功能：返回 `str` 中**第一个属于 `reject` 的字符的下标**（未找到返回 `str` 总长度）；
   - 核心用法：`str[strcspn(str, "\n")] = '\0'`（精准定位 `\n` 并替换为终止符）。

#### 高频易错点
| 易错点                | 表现/后果                          | 解决方案                                  |
|-----------------------|------------------------------------|-------------------------------------------|
| 参数顺序搞反          | `strcspn("\n", str)` 返回 0，处理无效 | 牢记顺序：第一个参数是待处理字符串，第二个是要查找的字符集 |
| 忽略空字符串场景      | 用户直接回车时，处理后字符串为空   | 增加判断：`if(strlen(str)==0) { 提示重新输入 }` |
| 类型错误              | 用 `int` 接收返回值，比较时出负数  | 返回值是 `size_t`（无符号），避免与负数比较 |

### 三、二维字符串（字符数组）核心重点 + 高频易错点
#### 核心重点
1. **定义规则**：`char strs[n][101]`（C99变长数组）/`char strs[1000][101]`（固定长度），**列数必须预留 `'\0'` 位置**（101 = 100个有效字符 + 1个终止符）；
2. **内存特性**：每行独立存储一个字符串，栈上分配（变长数组仅GCC/Clang支持）；
3. **排序核心**：
   - 用 `strcmp(strs[j], strs[j+1])` 比较字典序；
   - 用 `strcpy` 借助临时数组交换字符串；
   - 函数传参格式：`void func(char strs[][101], int n)`（列数固定，行数传参）。

#### 高频易错点
| 易错点                | 表现/后果                          | 解决方案                                  |
|-----------------------|------------------------------------|-------------------------------------------|
| 变长数组兼容性        | MSVC编译器报错“表达式需为常量”    | 改用固定数组 `char strs[1000][101]` 或动态内存 `malloc` |
| 数组维度越界          | 列数不足导致 `'\0'` 溢出（如 `char strs[n][4]` 存"mike"） | 列数 = 最大字符数 + 1，确保 `'\0'` 有位置 |
| 传参漏写列数          | `char strs[][]` 编译报错           | 函数参数必须固定列数：`char strs[][101]`  |
| 栈溢出                | n过大（如10000）导致程序崩溃       | 限制n范围（如≤1000）或改用堆内存 `malloc` |
| 命名混淆              | 函数参数名与主函数数组名重名       | 函数参数命名差异化（如主函数用`str`，函数用`strs`） |
| 冒泡排序效率低        | n≥1000时排序耗时剧增               | 初学用冒泡，实际场景替换为 `qsort`（O(n log n)） |

### 核心总结（速记）
1. fgets：读行必带 `size-1`，读完必清换行符，scanf后必清缓冲区；
2. strcspn：专解fgets换行符，参数顺序别搞反，空行场景要判断；
3. 二维字符串：列数留位存 `'\0'`，MSVC不用变长数组，排序用strcmp/strcpy，n大换堆内存。
