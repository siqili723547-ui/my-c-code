#include <stdio.h>  // 标准输入输出头文件

int main() {
    int n, m;  // n: 事件数量, m: 连续事件数量
    scanf("%d %d", &n, &m);  // 读取n和m的值
    
    // 根据题目规模，n最大为3000，所以数组大小设为3005
    int a[3005] = {0};      // 存储每个事件的刺痛值
    int b[3005] = {0};      // 存储每个连续m个刺痛值的和
    
    // 读取所有事件的刺痛值
    for(int i = 0; i < n; i++) {
        scanf("%d", &a[i]);  // &符号表示取a[i]的地址，将输入值存储到数组中
    }
    
    // 特殊情况处理：如果m=0，表示不需要选择任何事件
    if(m == 0) {
        printf("0");  // 空集合的和为0
        return 0;     // 直接结束程序
    }
    
    // 计算所有可能的连续m个刺痛值的和
    // 外层循环：遍历所有可能的起始位置
    // j的取值范围：0 到 n-m（包含）
    // 例如：n=8, m=3，则j从0到5，共6种可能
    for(int j = 0; j <= n - m; j++) {
        // 内层循环：从位置j开始，累加接下来的m个刺痛值
        // k从j开始，到j+m-1结束，共m个元素
        for(int k = j; k < j + m; k++) {
            b[j] += a[k];  // 将第k个刺痛值累加到b[j]中
        }
        // 此时b[j]中存储的是a[j]到a[j+m-1]这m个数的和
    }
    
    // 在所有连续m个刺痛值的和中找出最小值
    int x = b[0];  // 假设第一个和就是最小值
    // 遍历b数组中的所有和，从第2个开始比较（下标1）
    for(int l = 1; l <= n - m; l++) {
        if(x > b[l]) {  // 如果找到更小的和
            x = b[l];   // 更新最小值
        }
    }
    
    // 输出连续m个刺痛值的最小和
    printf("%d", x);
    
    return 0;  // 程序正常结束
}
-----------------------------------------------------------------------------------------
#include <stdio.h>

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    
    int a[3005] = {0};        // 存储原始刺痛值
    int prefix[3005] = {0};   // 前缀和数组
    // prefix[i] 表示前i个刺痛值的和（a[0]到a[i-1]的和）
    
    // 读取数据并计算前缀和
    for(int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
        // 计算前缀和：prefix[i+1] = 前i+1个数的和
        // prefix[0] = 0 (前0个数的和)
        // prefix[1] = a[0] (前1个数的和)
        // prefix[2] = a[0] + a[1] (前2个数的和)
        prefix[i + 1] = prefix[i] + a[i];
    }
    
    // 处理特殊情况
    if(m == 0) {
        printf("0");
        return 0;
    }
    
    // 设置一个很大的初始值，确保第一个和肯定比它小
    int min_sum = 1e9;  // 1e9 = 1000000000
    
    // 利用前缀和快速计算所有连续m个数的和
    for(int i = 0; i <= n - m; i++) {
        // 计算从位置i开始的连续m个数的和
        // 公式：sum = prefix[i+m] - prefix[i]
        // prefix[i+m] = 前i+m个数的和
        // prefix[i] = 前i个数的和
        // 两者相减得到第i到第i+m-1个数的和
        int sum = prefix[i + m] - prefix[i];
        
        // 更新最小值
        if(sum < min_sum) {
            min_sum = sum;
        }
    }
    
    printf("%d", min_sum);
    
    return 0;
}
