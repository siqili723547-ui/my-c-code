#include <stdio.h>
#include <math.h>

// 函数：判断是否为质数（素数）
// 参数：x - 待判断的整数
// 返回值：1表示是质数，0表示不是质数
int zhishu(int x) {
    // 特殊情况处理：2是最小的质数，也是唯一的偶数质数
    if (x == 2) return 1;
    // 排除小于2的数和偶数
    if (x < 2 || x % 2 == 0) return 0;
    
    // 计算检查上限：只需要检查到√x即可
    // 因为如果x有大于√x的因子，那么必定有小于√x的对应因子
    int limit = (int)sqrt(x);
    
    // 从3开始，每次加2（只检查奇数因子）
    // 注意：这里使用i <= limit，确保检查到上限值
    for (int i = 3; i <= limit; i += 2) {
        if (x % i == 0) return 0;  // 找到因子，不是质数
    }
    return 1;  // 没有找到因子，是质数
}

// 函数：判断是否为回文数
// 参数：x - 待判断的整数
// 返回值：1表示是回文数，0表示不是回文数
int huiwen(int x) {
    int original = x;      // 保存原始数值
    int reversed = 0;      // 存储反转后的数值，必须初始化为0
    
    // 反转数字：通过不断取余和除法操作
    // 例如：123 -> 3 -> 32 -> 321
    while (x > 0) {
        // 将反转数左移一位（×10），加上原数的最低位
        reversed = reversed * 10 + x % 10;
        // 移除原数的最低位
        x /= 10;
    }
    
    // 判断反转后的数是否等于原始数
    if (original == reversed) {
        return 1;  // 是回文数
    } else {
        return 0;  // 不是回文数
    }
}

// 主函数：找出给定范围内的既是质数又是回文数的整数
int main() {
    int a, b;  // 范围的下限和上限
    
    // 读取用户输入的区间
    // 输入格式：两个整数，用空格分隔
    scanf("%d %d", &a, &b);
    
    // 优化：如果a是偶数，加1使其变为奇数
    // 因为除了2以外，所有质数都是奇数
    // 这样可以减少一半的循环次数
    if (a % 2 == 0) a++;
    
    // 遍历区间[a, b]内的所有奇数
    // 注意：步长为2，只检查奇数
    for (int i = a; i <= b; i += 2) {
        // 同时满足回文数和质数条件
        if (huiwen(i) && zhishu(i)) {
            printf("%d\n", i);  // 输出符合条件的数
        }
    }
    
    return 0;  // 程序正常结束
}
