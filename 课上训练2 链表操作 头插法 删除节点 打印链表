#include <stdio.h>              // 引入标准输入输出头文件，用于scanf/printf
#include <stdlib.h>             // 引入标准库头文件，用于malloc/free/exit等内存操作

struct Node{
    int data;                   // 链表节点数据域：存储整数数据
    struct Node *next;          // 链表节点指针域：指向下一个节点，串联链表的核心
};

int main()
{
    struct Node *head=NULL;     // 链表头指针，初始化为NULL表示空链表
    struct Node *newNode=NULL;  // 临时指针：指向新创建的节点

    while(1){                   // 无限循环，输入-1时break终止链表创建
        int num=0;              // 存储输入数值，初始化0无意义（scanf会覆盖），冗余写法
        scanf("%d",&num);       // 读取用户输入的整数
        if(num==-1){            // 终止条件：输入-1停止创建链表
            break;
        }

        newNode=(struct Node*)malloc(sizeof(struct Node)); // 为新节点动态分配内存
        if(newNode==NULL){      // 校验内存分配是否失败，避免野指针
            exit(1);            // 内存分配失败则异常退出，退出码1表示错误
        }

        newNode->data=num;      // 给新节点数据域赋值
        newNode->next=head;     // 头插法：新节点next指向原链表头（空链表时为NULL）
        head=newNode;           // 关键：更新头指针为新节点（曾写反导致链表为空）
    }

    int del;
    scanf("%d",&del);           // 读取需要删除的目标数值

    struct Node *p=head;        // 遍历指针：从链表头开始遍历（必须从head起步）
    struct Node *prev=NULL;     // 前驱指针：记录当前节点的上一个节点，用于删除操作
    while(p){                   // 遍历终止条件：p=NULL（到链表尾部）
         struct Node *next_Node=p->next;   // 提前保存下一个节点（避免删除p后访问野指针）
        if(p->data==del){       // 判断当前节点是否为待删除节点
            if(prev==NULL){     // 情况1：删除头节点（prev为NULL说明是第一个节点）
                head=head->next;// 头指针后移（可优化为head=next_Node，逻辑更统一）
                free(p);        // 释放节点内存，避免内存泄漏
            }else{              // 情况2：删除中间/尾节点
                prev->next=p->next; // 前驱节点跳过当前节点，完成断链
                free(p);        // 释放当前节点内存
            }
        }else{                  // 不删除当前节点时，前驱指针后移
            prev=p;
        }
        p=next_Node;            // 遍历指针后移（必须用提前保存的next_Node）
    }

    struct Node *temp=head;     // 打印用遍历指针，从链表头开始
    while(temp){                // 遍历打印所有节点
        if(temp==head){         // 控制空格：第一个节点直接打印，无前置空格
            printf("%d",temp->data);
        }else{                  // 非第一个节点，先打印空格再打印数值
            printf(" %d",temp->data);
        }
        temp=temp->next;        // 指针后移（曾遗漏导致死循环）
    }

    return 0;                   // 程序正常退出
}



# 链表代码问题梳理与通用易错点总结
## 一、本次代码迭代中的具体问题梳理
本次代码围绕“头插法创建链表→删除指定值节点→打印链表”展开，迭代过程中暴露的核心问题如下：

| 问题类型               | 错误表现                                                                 | 直接后果                     |
|------------------------|--------------------------------------------------------------------------|------------------------------|
| 头插法逻辑颠倒         | `newNode = head;` （正确应为 `head = newNode;`）                         | 新节点无法接入链表，`head` 始终为空 |
| 删除节点野指针访问     | 删除 `p` 后直接 `p = p->next;`（`p` 已被 `free`，非法访问内存）          | 程序崩溃、内存访问异常       |
| 打印链表死循环         | 缺少 `temp = temp->next;`                                                | 程序无限循环，CPU 占用 100%  |
| 删除头节点逻辑不统一   | `head = head->next;`（未复用提前保存的 `next_Node`）                     | 逻辑冗余，后续修改易出错     |
| 打印格式鲁棒性差       | 用 `temp == head` 判断首节点（`head` 临时修改时判断失效）                | 输出多余/缺失空格            |
| 内存泄漏               | 未释放剩余链表内存                                                       | 小型程序无明显影响，大型程序内存溢出 |
| 冗余变量初始化         | `int num=0;`（`scanf` 会覆盖值，初始化无意义）                           | 代码冗余，可读性降低         |

## 二、链表开发通用高频易错点（附解决方案）
链表错误多集中在**指针操作、逻辑顺序、内存管理**三类，以下是全场景易错点总结，包含错误表现、原因及正确做法：

### （一）链表创建阶段易错点
#### 1. 头插/尾插法逻辑颠倒
- **错误表现**：新节点无法接入链表，链表始终为空或节点丢失；
- **错误原因**：混淆“新节点指向链表”和“链表头/尾指向新节点”的顺序；
- **正确做法**：
  - 头插法（核心：新节点永远做链表头）：
    ```c
    newNode->data = num;
    newNode->next = head;  // 先让新节点接原链表头
    head = newNode;        // 再更新头指针为新节点
    ```
  - 尾插法（核心：新节点永远做链表尾）：
    ```c
    newNode->data = num;
    newNode->next = NULL;  // 尾节点next必须置NULL
    if (head == NULL) {
        head = newNode;
        tail = newNode;    // 空链表时头/尾都指向新节点
    } else {
        tail->next = newNode;
        tail = newNode;    // 更新尾指针
    }
    ```

#### 2. 节点 `next` 指针未初始化
- **错误表现**：野指针、链表遍历异常；
- **错误原因**：第一个节点/尾节点未显式设置 `next = NULL`；
- **正确做法**：创建节点后直接初始化 `newNode->next = NULL`（头插法因 `newNode->next = head`，`head` 初始为 `NULL`，可间接实现，但尾插法必须显式设置）。

#### 3. 内存分配失败未处理
- **错误表现**：程序异常退出、崩溃；
- **错误原因**：`malloc` 返回 `NULL` 时直接使用节点；
- **正确做法**：分配后必须检查，示例：
  ```c
  newNode = (struct Node*)malloc(sizeof(struct Node));
  if (newNode == NULL) {
      printf("内存分配失败！\n");
      exit(1);  // 或返回错误码
  }
  ```

### （二）链表删除阶段易错点
#### 1. 删除节点后访问已释放指针（野指针）
- **错误表现**：程序崩溃、内存访问错误；
- **错误原因**：删除 `p` 后直接 `p = p->next`（`p` 已被 `free`，非法访问）；
- **正确做法**：提前保存下一个节点，示例：
  ```c
  struct Node *next_Node = p->next;  // 先保存下一个节点
  if (p->data == del) {
      // 处理删除逻辑...
      free(p);
  }
  p = next_Node;  // 用保存的地址后移，避免访问已释放内存
  ```

#### 2. 头节点删除逻辑遗漏
- **错误表现**：头节点无法删除，或删除后 `head` 指向野指针；
- **错误原因**：未区分“删除头节点”和“删除中间/尾节点”；
- **正确做法**：通过前驱节点 `prev` 判断，示例：
  ```c
  if (prev == NULL) {  // 删除头节点
      head = next_Node;  // 头指针指向原头节点的下一个节点
  } else {  // 删除中间/尾节点
      prev->next = next_Node;
  }
  ```

#### 3. 遍历指针未后移
- **错误表现**：链表遍历卡死，只处理第一个节点；
- **错误原因**：`while` 循环中未更新遍历指针；
- **正确做法**：循环末尾必须更新指针：`p = next_Node;`（或 `p = p->next;`）。

#### 4. 忘记释放删除节点的内存
- **错误表现**：内存泄漏；
- **错误原因**：仅修改指针指向，未调用 `free(p)`；
- **正确做法**：删除节点时必须释放内存：`free(p);`（释放后可置 `p=NULL`，避免后续误判）。

### （三）链表遍历/打印阶段易错点
#### 1. 遍历死循环
- **错误表现**：程序无限循环，无法终止；
- **错误原因**：① 缺少指针后移（如 `temp = temp->next;`）；② 链表尾节点 `next` 未置 `NULL`；
- **正确做法**：
  - 遍历循环内必加 `temp = temp->next;`；
  - 确保所有尾节点 `next = NULL`。

#### 2. 打印格式错误（多余/缺失空格）
- **错误表现**：输出开头/结尾有空格，不符合格式要求；
- **错误原因**：用指针地址（如 `temp == head`）判断首节点，易受 `head` 修改影响；
- **正确做法**：用布尔变量标记首节点，示例：
  ```c
  int is_first = 1;
  while (temp) {
      if (is_first) {
          printf("%d", temp->data);
          is_first = 0;
      } else {
          printf(" %d", temp->data);
      }
      temp = temp->next;
  }
  ```

### （四）内存管理易错点
#### 1. 未释放链表剩余内存
- **错误表现**：内存泄漏，长期运行占用内存递增；
- **错误原因**：认为“程序结束系统会回收”，忽略显式释放的规范；
- **正确做法**：程序结束前遍历释放所有节点：
  ```c
  struct Node *temp = head;
  while (temp) {
      struct Node *tmp = temp;
      temp = temp->next;
      free(tmp);  // 逐个释放
  }
  head = NULL;  // 释放后置空头指针，避免野指针
  ```

#### 2. 重复释放/释放空指针
- **错误表现**：程序崩溃（`double free` 错误）；
- **错误原因**：释放节点后未置 `NULL`，后续误判再次释放；
- **正确做法**：`free(p)` 后立即 `p = NULL`；释放前检查 `if (p != NULL)`。

### （五）变量使用易错点
#### 1. 遍历指针初始位置错误
- **错误表现**：遍历不到部分节点（如从最后一个节点开始遍历）；
- **错误原因**：初始化 `p` 为非 `head` 的指针；
- **正确做法**：遍历链表必须从 `head` 开始：`struct Node *p = head;`。

#### 2. 冗余变量初始化
- **错误表现**：代码冗余，可读性降低；
- **错误原因**：对 `scanf`/`cin` 等输入函数的“覆盖赋值”特性理解不足；
- **正确做法**：变量就近定义，仅需默认值时初始化（如 `int num;` 而非 `int num=0;`）。

## 三、核心避坑原则
1. **指针操作先保存**：修改/删除节点前，先保存下一个节点的地址，避免断链/野指针；
2. **逻辑顺序要严谨**：头插/尾插、删除头节点的核心逻辑顺序不能颠倒；
3. **内存管理要闭环**：`malloc` 必须配 `free`，释放后置 `NULL`；
4. **遍历必更指针**：循环内必须更新遍历指针，且确保尾节点 `next = NULL`；
5. **边界条件要覆盖**：空链表、单节点链表、删除头/尾节点的场景需单独验证。
      
