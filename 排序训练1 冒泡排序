#include <stdio.h>
#include <stdlib.h>

#define MAXN 100005

// 定义结构体，用于同时存储元素的值和原始下标
typedef struct {
    int value;          // 元素的值
    int original_index; // 元素在原始数组中的下标
} Pair;

// 比较函数用于排序
int compare(const void *a, const void *b) {
    Pair *pa = (Pair *)a;
    Pair *pb = (Pair *)b;
    
    // 首先按元素的值进行升序排序
    if (pa->value != pb->value) {
        return pa->value - pb->value;
    }
    // 如果值相同，则按原始下标排序（保持稳定排序）
    // 这样可以确保值相同的元素在排序后保持原来的相对顺序
    return pa->original_index - pb->original_index;
}

int main() {
    int N;
    Pair A[MAXN];  // 定义结构体数组
    
    // 读取输入数据
    scanf("%d", &N);
    for (int i = 0; i < N; i++) {
        scanf("%d", &A[i].value);      // 读取元素值
        A[i].original_index = i;       // 记录当前元素在原始数组中的位置
    }
    
    // 使用快速排序对数组进行排序
    // 参数说明：
    // A - 要排序的数组
    // N - 数组元素个数
    // sizeof(Pair) - 每个元素的大小
    // compare - 比较函数指针
    qsort(A, N, sizeof(Pair), compare);
    
    int max_offset = 0;  // 记录最大的偏移量
    
    // 遍历排序后的数组，计算每个元素的偏移量
    for (int i = 0; i < N; i++) {
        // 计算偏移量 = 原始下标 - 新下标
        // 这个偏移量表示该元素需要向左移动的步数
        int offset = A[i].original_index - i;
        
        // 更新最大偏移量
        if (offset > max_offset) {
            max_offset = offset;
        }
    }
    
    // 输出结果：最大偏移量 + 1 就是 "moo" 的输出次数
    // 为什么是 max_offset + 1？
    // - max_offset 表示某个元素需要移动的轮数
    // - 但冒泡排序在开始第一轮时就会先输出一次 "moo"
    // - 所以总轮数 = 移动轮数 + 1
    printf("%d\n", max_offset + 1);
    
    return 0;
}
