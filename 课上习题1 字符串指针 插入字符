插入字符
【问题描述】
编写一函数char * insert(char *string, char c)，用于在一个已排好序（ASCII值从小到大）的字符串string（少于50个字符）中适当位置插入字符c，要求插入后字符串的序不变（从小到大），允许字符重复，函数返回插入后的字符串的首地址。
在main函数中测试该函数：先从键盘分别输入有序字符串和单个字符，然后调用insert函数，最后将insert函数返回值赋值给一个字符指针变量，在main函数中实现输出插入后的字符串。
【输入形式】
从键盘分行输入有序字符串和单个字符
【输出形式】
在main函数中实现：向屏幕输出插入后的字符串
【输入样例】

abdef   
c
【输出样例】

abcdef
【样例说明】
从键盘输入少于50个字符的有序字符串abdef和字符c，通过调用函数char * insert(char *string, char c)将字符c插入字符串abdef，并以ASCII值从小到大排序输出



#include <stdio.h>      // 引入标准输入输出头文件，用于scanf、printf等函数
#include <string.h>     // 引入字符串处理头文件，用于strlen等字符串操作函数

/**
 * 函数功能：将字符c按非递增顺序插入到字符串string的对应位置
 * 参数说明：
 *   string - 待插入的目标字符串（字符数组），要求有足够空间存储插入后的结果
 *   c      - 要插入的单个字符
 * 返回值：返回插入字符后的字符串首地址（即原string的地址）
 */
char* insert(char *string, char c) {
    // 1. 获取原字符串的长度（不包含末尾的'\0'）
    int len = strlen(string);
    // 2. 初始化插入位置为字符串起始位置（下标0）
    int pos = 0;

    // 3. 寻找插入位置：循环比较字符，直到找到第一个比c小的字符位置
    //    循环条件：pos未到字符串末尾 且 待插入字符c大于等于当前位置字符
    //    逻辑：保证插入后字符串仍保持非递增（从大到小）的顺序
    while (pos < len && c >= string[pos]) {
        pos++;
    }

    // 4. 从插入位置的末尾开始，将字符向后移动一位，为插入c腾出空间
    //    倒序移动避免字符覆盖（如果正序移动会先覆盖后面的字符）
    for (int i = len - 1; i >= pos; i--) {
        string[i + 1] = string[i];
    }

    // 5. 将字符c插入到找到的目标位置pos
    string[pos] = c;
    // 6. 为新字符串添加结束符（原长度len，插入后长度len+1，结束符在len+1位置）
    string[len + 1] = '\0';

    // 7. 返回插入后的字符串首地址
    return string;
}

int main() {
    // 定义字符数组，长度55（足够存储输入字符串+插入1个字符+结束符）
    char string[55];
    // 定义要插入的字符c
    char c;

    // 8. 输入原始字符串（注意：scanf("%s")会自动忽略空格/换行，读取到第一个空白符为止）
    scanf("%s", string);
    // 9. 输入要插入的字符（前面加空格" %c"，跳过输入字符串后残留的换行符/空格）
    scanf(" %c", &c);

    // 10. 调用insert函数，将字符c插入字符串，并接收返回的字符串地址
    char *result = insert(string, c);
    // 11. 输出插入后的最终字符串
    printf("%s", result);

    return 0;
}


笔记区
# 核心知识点归纳 + 字符串常见易错点补充
## 一、核心知识点归纳（按主题分类）
### （一）输入输出：scanf/printf/getchar 核心规则
#### 1. 缓冲区与空白字符（换行\n、空格、制表符\t）
- 核心结论：按回车键**必然**向输入缓冲区写入`\n`；`\n`是否残留，取决于后续读取操作是否处理它。
- 格式符对空白字符的处理（最核心坑点）：
  | %d/%f/%s    | 自动跳过**开头**所有空白（\n/空格/\t），读取到第一个空白时停止 | 输入结束后的空白会残留缓冲区，影响后续%c/getchar |
  | %c/getchar  | 不跳过任何字符，直接读取缓冲区第一个字符 | 极易读取到前序操作残留的\n/空格/\t |
- 解决空白干扰的3种方法：
  1. %c前加空格：`scanf(" %c", &c);`（最简单，自动跳过所有空白）；
  2. 用getchar清空残留：`getchar(); // 吃掉前序的\n`；
  3. 循环清空缓冲区（最彻底）：`while (getchar() != '\n');`。

#### 2. 不同类型数据的输入输出规则
| 字符数组（字符串） | 传数组名（首元素地址），无需&；%s读至空白停止 | 传数组名/指针（首元素地址）；%s自动遍历至\0停止 |
| 单个int/float  | 必须传地址（&变量/指针），仅写单个值 | 直接传值，传地址会打印内存地址 |
| 单个char       | 传地址（&c）；%c/getchar读单个字符 | 直接传值（%c），传地址打印地址 |
- 读取单个字符的优先级：`scanf(" %c", &c)`（首选） > `getchar()`（需清缓冲区） > `%s`间接读（不推荐，易越界）。

### （二）字符数组/字符串操作（以插入字符为例）
#### 1. 字符后移的2种正确写法（核心：从后往前移，避免覆盖）
```c
// 写法1（你常用的）：从最后一个有效字符开始
for(int i = len-1; i >= pos; i--) { string[i+1] = string[i]; }
// 写法2：从原结束符位置开始
for(int i = len; i > pos; i--) { string[i] = string[i-1]; }
```
- 关键：数组必须预留足够空间（如char string[55]，避免越界）。

#### 2. 字符串结束符`\0`的铁律
- C语言字符串本质：`有效字符 + 末尾\0`（\0是“哨兵标记”，告诉程序字符串结束）；
- 移动/插入字符后，原\0会被有效字符覆盖，**必须在新末尾（len+1）补\0**；
- 无\0后果：printf("%s")输出乱码、strlen/strcpy等函数失控。

#### 3. 插入位置逻辑
- 升序插入：`while(pos < len && string[pos] <= c) { pos++; }`（找到第一个比c大的位置）；
- 移动后pos位置的旧数据会被新字符覆盖，属于正常过程，无害。

### （三）数组名与指针的本质
- 数组名 = 数组首元素的**常量指针**（固定指向第一个元素，不可修改）；
- 传数组名给函数/scanf/printf，本质是传递“首元素地址”，而非整个数组。

## 二、字符串常见易错点补充（高频踩坑）
### 1. 数组越界（最致命，易导致程序崩溃/数据篡改）
- 错误示例：定义`char str[5];`，却存入6个字符（含\0）；
- 根源：未预留足够空间（如插入/拼接字符串时，数组长度需≥原长度+操作长度+1）；
- 规避：定义数组时预留冗余空间（如char str[100]），或用strlen提前计算长度。

### 2. 混淆strlen和sizeof（最易混淆）
| strlen      | 计算字符串**有效长度** | 从首地址到\0（不含\0） | strlen(str) = 3 |
| sizeof      | 计算变量/数组**内存大小** | 整个数组/变量的字节数 | sizeof(str) = 4（3个字符+1个\0） |
- 易错场景：用sizeof计算字符串有效长度，或用strlen计算数组内存大小。

### 3. 直接赋值字符串（char[] vs char* 区别）
- 错误示例1：`char str[10]; str = "hello";`（数组名是常量指针，不可赋值）；
  正确：`strcpy(str, "hello");` 或 初始化时赋值`char str[10] = "hello";`；
- 错误示例2：`char *p; p = "hello"; p[0] = 'H';`（字符串常量存只读区，不可修改）；
  正确：`char p[] = "hello"; p[0] = 'H';`（存栈区，可修改）。

### 4. strcpy/strcat的越界风险
- 错误示例：`char str[5]; strcpy(str, "hello world");`（目标数组空间不足）；
- 规避：
  1. 用strncpy/strncat替代（指定最大拷贝长度）：`strncpy(str, "hello", sizeof(str)-1); str[sizeof(str)-1] = '\0';`；
  2. 提前用strlen检查长度。

### 5. 忽略字符串末尾的\0
- 错误示例：手动初始化字符数组时漏加\0：`char str[] = {'a','b','c'}; printf("%s", str);`（输出乱码）；
- 正确：`char str[] = {'a','b','c','\0'};` 或直接`char str[] = "abc";`（自动补\0）。

### 6. 用scanf("%s")读取带空格的字符串
- 错误示例：输入`hello world`，`scanf("%s", str);` 仅读取`hello`（遇到空格停止）；
- 正确：用fgets读取带空格的字符串：
  ```c
  char str[100];
  fgets(str, sizeof(str), stdin); // 读取整行（含空格），注意会包含换行符\n
  str[strcspn(str, "\n")] = '\0'; // 可选：去掉fgets读取的换行符
  ```

### 7. 函数传参时数组退化为指针
- 错误示例：函数内用sizeof计算传入的数组长度：
  ```c
  void test(char str[]) { printf("%d", sizeof(str)); } // 输出4/8（指针大小），而非数组长度
  ```
- 规避：传数组时同时传递长度：`void test(char str[], int len) { ... }`。

### 8. 字符与数字的ASCII码混淆
- 错误示例：`char c = '5'; int num = c;`（num=53，而非5）；
- 正确：`int num = c - '0';`（利用ASCII码差值转换）；
- 反向转换：`char c = num + '0';`（num需≤9）。

## 三、总结
字符串操作的核心是“控边界（避免越界） + 盯\0（保证结束符） + 理缓冲区（处理空白）”，记住以上规则，能避开90%的字符串坑。

