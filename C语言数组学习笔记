10.21 零零总总已经写了十道数组题了 目前最大的问题就是写题的速度太慢了 伪代码无法快速变现 
这些题目里面遇到的一些问题：
1.数组设置大小问题 数组总会越界 在循环的时候一不注意就会出现超出数组界限的情况
2.字符数组不知道输出格式 数组训练9需要重新写一遍
3，





数组训练 11
1.found标记 在嵌套循环当中帮助提高效率 找到需要的值之后就可以吧found赋值1 拿这个当踏板的判定条件跳出循环 提高效率
例子 int found=0；//设置found标记 使他的状态为false即是0
在需要借助found标记时 使found=1; //改变标记状态
最后在特定的条件语句中充当判断条件 如 if（found）{...}//表示判定found是否为ture 即found是否为1

2.在构思略显复杂的嵌套循环时 还是从最内层开始思考 比如这个问题 我们需要在数组中找到三个不同的值 使他们满足两者相加等于第三者 我们要借助for循环来遍历数组寻找符合的对象的同时 不遗漏情况 显
然最内层循环我们得找两个相加数 我们就得从第一个数字开始向后依次推进 然后上一层循环也需要遍历 但是值得注意遍历的是同一个数组 然后如果从头开始遍历将会降低程序运行的效率 例如1+1 1+2 1+3.... 
到后面3+1的时候就和前面的情况一样了 所以我们构造上一层循环需要保证起始值与最内层的数组相同 题目还要求两相加数字不相同 所以上一层循环的初始值得比最内层大1

3.最外层循环是简单的遍历数组 前两个循环的数字相加看是否等于 借助标记 如果找到相符的值就修改标记状态 借助条件语句 快速跳过剩余循环 提高效率 



10.23
数组训练13
1.寻找出现次数最多的最小和中 求次数多的是很简单的 直接用擂台法依次比较就好 但是面对可能出现的情况是 有的和出现的次数也是最多的 该如何把最小的和挑出来 只要顺序打擂台 建立一个临时变量把最先出现的那个最小和保存下来就好了

数组训练14
1.一般的整数转换 int x=（int）（a*5）；
更加高级的写法 向下取整 需要设置头文件
#include <math.h> 
floor();
2.定义数组的最大边界
#define MAX_N 2000000
int lights[MAX_SIZE] = {0}; 
3.异或运算 相同为0 不同为1
// 传统写法：
if(lights[id] == 0) lights[id] = 1;
else lights[id] = 0;

// 异或写法（更简洁高效）：
lights[id] ^= 1;

10.26
数组训练16
1.1-base坐标 a[1][1]对应第一行第一列 避免坐标转换带来的错误
2.曼哈顿距离 坐标上的两点之间的横纵坐标差值的和 需要用到绝对值函数
#include <stdilib.h>
abs(...)
