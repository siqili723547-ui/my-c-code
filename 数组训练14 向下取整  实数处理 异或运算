#include <stdio.h>

int main()
{
    int n;  // 定义变量n，表示操作次数
    double a[5005];  // 定义数组a，存储每次操作的实数a（最多5000次操作）
    int t[5005];     // 定义数组t，存储每次操作的整数t（最多5000次操作）
    int c[2000005] = {0};  // 定义灯状态数组c，大小为2000005，初始所有灯为关（0）
                           // 多分配一些空间防止数组越界
    
    // 读取操作次数n
    scanf("%d", &n);
    
    // 读取输入：循环n次，读取每次操作的a和t值
    for(int i = 0; i < n; i++) {
        scanf("%lf %d", &a[i], &t[i]);  // %lf用于读取double类型的实数a
                                       // %d用于读取整数t
    }
    
    // 模拟开关操作：遍历每一次操作
    for(int j = 0; j < n; j++) {
        // 对当前操作的第j次，循环t[j]次（从1到t[j]）
        for(int k = 1; k <= t[j]; k++) {
            // 计算要操作的灯编号：x = floor(a[j] * k)
            // 通过直接转换为int来截断小数部分，实现向下取整
            int x = (int)(a[j] * k);
            
            // 切换灯的状态：
            // 如果灯当前是关的（c[x] == 0），则打开（设为1）
            // 如果灯当前是开的（c[x] == 1），则关闭（设为0）
            if(c[x] == 0) {
                c[x] = 1;  // 关 → 开
            } else {
                c[x] = 0;  // 开 → 关
            }
        }
    } 
    
    // 寻找亮着的灯：因为题目保证最终只有一盏灯是亮的
    int found = 0;  // 标志变量，0表示还没找到，1表示找到了
    int p = 1;      // 从灯编号1开始查找（因为灯编号从1开始）
    
    // 循环查找，直到找到亮着的灯
    while(found == 0) {
        // 检查当前编号p的灯是否亮着
        if(c[p] == 1) {
            found = 1;  // 找到了，设置标志为1
        } else {
            p++;        // 没找到，检查下一个编号
        }
    }
    
    // 输出唯一亮着的灯的编号
    printf("%d", p);
    
    return 0;
}
----------------------------------------------------------------------------------------------------------------
#include <stdio.h>

int main() {
    int n;  // 定义变量n，用于存储操作次数
    scanf("%d", &n);  // 从输入读取操作次数n
    
    // 定义灯状态数组，大小为2000005，初始所有元素为0（表示所有灯都是关的）
    // 数组索引直接对应灯的编号，例如lights[1]表示编号为1的灯的状态
    int lights[2000005] = {0};
    
    // 循环处理每一次操作
    for(int i = 0; i < n; i++) {
        double a;  // 定义实数a，用于存储本次操作的实数参数
        int t;     // 定义整数t，用于存储本次操作的次数
        
        // 读取本次操作的a和t值
        // %lf用于读取double类型的浮点数，%d用于读取整数
        scanf("%lf %d", &a, &t);
        
        // 对当前操作，循环t次（从1到t）
        for(int k = 1; k <= t; k++) {
            // 计算要操作的灯编号：id = floor(a × k)
            // 通过直接转换为int来截断小数部分，实现向下取整
            int id = (int)(a * k);
            
            // 使用异或运算切换灯的状态：
            // lights[id] ^= 1 等价于 lights[id] = lights[id] ^ 1
            // 异或运算规则：0 ^ 1 = 1（关→开），1 ^ 1 = 0（开→关）
            lights[id] ^= 1;
        }
    }
    
    // 在所有操作完成后，寻找唯一亮着的灯
    // 从编号1开始遍历到2000000（题目保证t_i×a_i最大值不超过2000000）
    for(int i = 1; i < 2000000; i++) {
        // 检查当前灯是否亮着（lights[i] == 1）
        if(lights[i]) {
            // 找到亮着的灯，输出其编号
            printf("%d", i);
            break;  // 由于题目保证只有一盏灯亮着，找到后立即退出循环
        }
    }
    
    return 0;  // 程序正常结束
}
