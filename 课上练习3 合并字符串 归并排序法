合并字符串
【问题描述】
编写一个函数void  str_bin(char str1[ ], char str2[ ])， str1、str2是两个有序字符串（其中字符按ASCII码从小到大排序），将str2合并到字符串str1中，要求合并后的字符串仍是有序的，允许字符重复。在main函数中测试该函数：从键盘输入两个有序字符串，然后调用该函数，最后输出合并后的结果。
【输入形式】
分行从键盘输入两个有序字符串（不超过100个字符）
【输出形式】
输出合并后的有序字符串
【输入样例】

aceg
bdfh
【输出样例】

abcdefgh

#include <stdio.h>  // 引入标准输入输出头文件，支持scanf、printf等函数
#include <string.h>  // 引入字符串处理头文件，支持strlen（求长度）、strcpy（字符串拷贝）等函数

// 自定义函数：将两个有序字符串合并为一个有序字符串，结果存入str1
// 参数str1[]: 第一个有序字符串（最终存储合并结果）；str2[]: 第二个有序字符串
void str_bin(char str1[], char str2[]) {
    char temp[205];  // 定义临时数组，容量205（可容纳2个100字符的字符串+1个结束符），避免溢出
    size_t s1 = strlen(str1);  // 计算str1的有效长度（不含'\0'），size_t适配字符串长度的无符号特性
    size_t s2 = strlen(str2);  // 计算str2的有效长度（不含'\0'）
    int k = 0, t = 0, j = 0;  // 定义遍历指针：k遍历str1，t遍历str2，j遍历temp，初始化为0

    // 双指针循环：同时遍历str1和str2，按字符大小合并到temp
    while (k < s1 && t < s2) {  // 条件：两个字符串都未遍历完
        if (str1[k] < str2[t]) {  // 比较当前字符，str1的字符更小（修复原代码缺失右括号问题）
            temp[j++] = str1[k++];  // 将str1当前字符存入temp，j和k同时后移
        } else {  // str2的字符更小或相等
            temp[j++] = str2[t++];  // 将str2当前字符存入temp，j和t同时后移
        }
    }

    // 处理str1剩余字符：若str1未遍历完，将剩余字符全部拷贝到temp
    while (k < s1) {  // 条件：str1还有未处理的字符
        temp[j++] = str1[k++];  // 剩余字符存入temp，j和k后移（修复原代码str1k++的拼写错误）
    }

    // 处理str2剩余字符：若str2未遍历完，将剩余字符全部拷贝到temp
    while (t < s2) {  // 条件：str2还有未处理的字符
        temp[j++] = str2[t++];  // 剩余字符存入temp，j和t后移（修复原代码缺失分号问题）
    }

    temp[j] = '\0';  // 手动添加字符串结束符，C语言字符串必须以'\0'结尾，否则输出乱码
    strcpy(str1, temp);  // 将合并后的temp内容拷贝到str1（数组名是常量指针，不能直接赋值，需用strcpy修改实参）
}

int main() {  // 主函数，程序入口
    char str1[205];  // 定义存储合并结果的数组，容量205（避免合并后溢出，原代码101容量不足）
    char str2[101];  // 定义第二个输入字符串数组，容量101（100个有效字符+1个结束符）
    scanf("%s", str1);  // 读取第一个输入字符串（无空格），存入str1
    scanf("%s", str2);  // 读取第二个输入字符串（无空格），存入str2
    str_bin(str1, str2);  // 调用合并函数，将结果存入str1
    printf("%s", str1);  // 输出合并后的有序字符串
    return 0;  // 主函数正常退出，返回0
}


# 有序字符串合并（归并类）题目常见问题总结
这类以“合并两个有序字符串/数组为新有序结果”为核心的题目，核心考察C语言字符串操作+归并算法基础，常见问题可归纳为五大类，每类均指向基础语法、语言特性或算法逻辑的核心疏漏：

### 1. 语法层面的低级书写失误
这类问题直接导致代码编译失败，多为书写疏忽所致：
- 符号缺失/误用：条件/循环语句括号不匹配、语句末尾漏写分号、循环条件后多写分号导致逻辑空转；
- 语法书写错误：数组下标访问漏写中括号（如`str1k`而非`str1[k]`）、变量名拼写错误（大小写混淆/字母错写）、比较运算符与赋值运算符混用（如`=`替代`<`）。

### 2. 字符串核心特性认知不足
这类问题源于对C语言字符串本质的不掌握，易导致运行时输出异常：
- 头文件遗漏：使用`strlen`/`strcpy`/`strcat`等字符串库函数时，未包含`<string.h>`头文件；
- 忽略结束符：合并/拼接字符串后未手动添加`'\0'`（C语言字符串必须以结束符收尾），导致输出乱码；
- 库函数误用：用`strcat`拼接未初始化的数组、用`strcpy`拷贝超长字符串引发溢出。

### 3. 算法逻辑的边界与完整性漏洞
这类问题导致合并结果错误，是算法设计的核心疏漏：
- 剩余元素处理不完整：归并循环结束后，仅复制单个剩余字符，未通过循环遍历所有未处理的字符；
- 合并条件错误：比较运算符写反（如升序合并误用`>`）、未处理字符相等的场景，导致结果无序；
- 循环边界越界：循环条件写错（如`k <= s1`而非`k < s1`），引发数组越界访问。

### 4. 内存与容量规划失误
这类问题易导致程序运行时崩溃或数据溢出，源于内存认知不足：
- 数组容量不足：结果数组仅定义为单个字符串的长度，未考虑两个字符串合并后的最大长度，引发缓冲区溢出；
- 局部数组滥用：试图返回函数内局部数组的地址（局部数组出函数后栈空间销毁，产生野指针）；
- 输入溢出：使用`scanf`读入字符串时未限制长度，导致超长输入超出数组容量。

### 5. 参数传递规则误解
这类问题源于对C语言数组/指针传参逻辑的不理解，导致无法正确修改实参：
- 错误赋值数组名：试图通过`str1 = temp`直接赋值数组名（数组名是常量指针，无法被赋值），正确方式应使用`strcpy`拷贝内容；
- 实参传递不当：将只读字符串字面量（如`"abc"`）传递给形参并试图修改（字面量存储在只读区域，修改会触发崩溃）；
- 形参校验缺失：形参定义为`char*`却未检查空指针，传入`NULL`时导致程序崩溃。
